#include <Rcpp.h>

using namespace Rcpp;


// J1 function with avoidance of singularity problem
// [[Rcpp::export]]
double cJfunc1(double k,
	      double l,
	      double t){
  
  double Jout, del;

  del = (k-l)*t;
    
  if(abs(del)>1e3) {
      
    Jout = ((exp(-l*t)-exp(-k*t))/(k-l)); // for all del>1e-3
  } else {  
      
    Jout = 0.5*t*(exp(-k*t)+exp(-l*t))*(1.0-del*del/12.0);
	
  }
    
    
  return Jout;
  
} //Jfunc1


// J2 function
// some version of the foursail code have an alternative j3 function 
// [[Rcpp::export]]
double cJfunc2or3(double k,
		 double l,
		 double t) {

  double  Jout;
  Jout = (1-exp(-(k+l)*t))/(k+l);
  return Jout;

} // Jfunc2 or 3



// J4 function for treating (near) conservative scattering
// used in foursail2
// [[Rcpp::export]]
double cJfunc4(double m, double t){
  
  double del =m*t;
  double e, Jout;
  
  if(del>1e-3){

      // sub1
    e = exp(-del);
    Jout = (1.0-e)/(m*(1.0+e));
    
  } else {

    // sub2
    e = m*0;
    Jout = 0.5*t*(1.0-del*del/12.0);
      
      }
  
  
  return Jout;
  
} // Jfunc4


//' Single layer reflection and transmission function 
//' 4sail
//' \code{cReflTrans} calculates
//' @param rho numeric vector of particle reflectance
//' @param tau numeric vector of particle transmission
//' @param lai leaf area index
//' @param att 
//' @param m
//' @param sigb
//' @param ks
//' @param ko
//' @param sf
//' @param sb
//' @param vf
//' @param vb
//' 
//' @author Marco D. Visser
//' @return Returns a list of reflectances
//' @export
// [[Rcpp::export]]
List cReflTrans(NumericVector rho,
			 NumericVector tau,
			 double lai,
			 NumericVector att,
			 NumericVector m,
			 NumericVector sigb,
			 double ks,
			 double ko,
			 NumericVector sf,
			 NumericVector sb,
			 NumericVector vf,
			 NumericVector vb){

  // result vectors
  NumericVector rdd(rho.size());
  NumericVector tdd(rho.size());
  NumericVector tsd(rho.size());
  NumericVector rsd(rho.size());
  NumericVector tdo(rho.size());
  NumericVector rdo(rho.size());
  NumericVector rsod(rho.size());

  // result doubles
  double tss   = exp(-ks*lai);
  double too   = exp(-ko*lai);
  double z     = cJfunc2or3(ks,ko,lai);

  // return list
  List ret;

  // helper doubles
  //  double e1,e2,rinf,rinf2,re,denom;
  //  double J1ks,J2ks,J1ko,J2ko;
  //  double Ps,Qs,Pv,Qv;
  //  double z,g1,g2;
  //  double Tv1,Tv2,T1,T2,T3;
    
  //  NumericVector xx = exp( x );

  for(int i =0; i < rho.size(); i++){

    double e1    = exp(-m[i]*lai);
    double e2    = e1*e1;
    double rinf  = (att[i]-m[i])/sigb[i];
    double rinf2 = rinf*rinf;
    double re    = rinf*e1;
    double denom = 1-rinf2*e2;
    	   
    // Jfunctions sun and observer
    double J1ks = cJfunc1(ks,m[i],lai);
    double J2ks = cJfunc2or3(ks,m[i],lai);
    double J1ko = cJfunc1(ko,m[i],lai);
    double J2ko = cJfunc2or3(ko,m[i],lai);

    double Ps    = (sf[i]+sb[i]*rinf)*J1ks;
    double Qs    = (sf[i]*rinf+sb[i])*J2ks;
    double Pv    = (vf[i]+vb[i]*rinf)*J1ko;
    double Qv    = (vf[i]*rinf+vb[i])*J2ko;

    rdd[i]   = rinf*(1-e2)/denom;
    tdd[i]   = (1-rinf2)*e1/denom;
    tsd[i]   = (Ps-re*Qs)/denom;
    rsd[i]   = (Qs-re*Ps)/denom;
    tdo[i]   = (Pv-re*Qv)/denom;
    rdo[i]   = (Qv-re*Pv)/denom;

    double g1    = (z-J1ks*too)/(ko+m[i]);
    double g2    = (z-J1ko*tss)/(ks+m[i]);

    double Tv1   = (vf[i]*rinf+vb[i])*g1;
    double Tv2   = (vf[i]+vb[i]*rinf)*g2;
    double T1    = Tv1*(sf[i]+sb[i]*rinf);
    double T2    = Tv2*(sf[i]*rinf+sb[i]);
    double T3    = (rdo[i]*Qs+tdo[i]*Ps)*rinf;

    // Multiple scattering contribution to bidirectional canopy reflectance
    rsod[i] = (T1+T2-T3)/(1-rinf2);
      }


  return Rcpp::List::create(rdd,tdd,tsd,rsd,tdo,rdo,tss,too,rsod);

} // ReflTrans






//' Single layer for two layer prospect
//' 4sail2
// [[Rcpp::export]]
List cReflTransSingleLayer(NumericVector rho, NumericVector tau,
			   double lai,
			   double ks, double ko,
			   double sdf,double sdb, double dof, double dob,
			   double sob,double sof,double  ddb,double  ddf){

  //output
  NumericVector rdd(rho.size());
  NumericVector rsd(rho.size());
  NumericVector rdo(rho.size());
  NumericVector rsod(rho.size());
  NumericVector tdd(rho.size());
  NumericVector tsd(rho.size());
  NumericVector tdo(rho.size());
  NumericVector w(rho.size());

  // constants
  
  double tss = exp(-ks*lai);
  double too = exp(-ko*lai);
    
  for(int i =0; i < rho.size(); i++){
    
    //Here the reflectance and transmission come in
    //with the suits coefficients

    //RTgeomRes function in R
    double sb = sdb*rho[i]+sdf*tau[i];
    double sf = sdf*rho[i]+sdb*tau[i];
    double vb = dob*rho[i]+dof*tau[i];
    double vf = dof*rho[i]+dob*tau[i];
    w[i] = sob*rho[i]+sof*tau[i];
    
    double sigb = ddb*rho[i]+ddf*tau[i];
    double sigf = ddf*rho[i]+ddb*tau[i];
    double att = 1.0-sigf;

    double m2 = (att+sigb)*(att-sigb);
    double m;

    if(m2<0){
      m = 0;
    } else {
      m = sqrt(m2);

    }
       
    double J1ks = cJfunc1(ks,m,lai);
    double J2ks = cJfunc2or3(ks,m,lai);
    double J1ko = cJfunc1(ko,m,lai);
    double J2ko = cJfunc2or3(ko,m,lai);
    double z  = cJfunc2or3(ks,ko,lai);
    double J4 = cJfunc4(m,lai);

     // condition 1
    if(m>0.01) {

      // Normal case
      double e1 = exp(-m*lai);
      double e2 = e1*e1;
      double rinf = ((att-m)/sigb);
      double rinf2 = rinf*rinf;
      double re = rinf*e1;
      double denom = 1.0-rinf2*e2;

      double Ps  =  (sf+sb*rinf)*J1ks;
      double Qs = (sf*rinf+sb)*J2ks;
      double Pv = (vf+vb*rinf)*J1ko;
      double Qv = (vf*rinf+vb)*J2ko;
    
      rdd[i] = rinf*(1.0-e2)/denom;
      tdd[i] = (1.0-rinf2)*e1/denom;
    
      tsd[i] = (Ps-re*Qs)/denom;
      rsd[i] = (Qs-re*Ps)/denom;
      tdo[i] = (Pv-re*Qv)/denom;
      rdo[i] = (Qv-re*Pv)/denom;
    
      double g1 = (z-J1ks*too)/(ko+m);
      double g2 = (z-J1ko*tss)/(ks+m);

      double Tv1 = (vf*rinf+vb)*g1;
      double Tv2 = (vf+vb*rinf)*g2;
      double T1 = Tv1*(sf+sb*rinf);
      double T2 = Tv2*(sf*rinf+sb);
      double T3 = (rdo[i]*Qs+tdo[i]*Ps)*rinf;

      // Multiple scattering contribution to
      //bidirectional canopy reflectance
      
      rsod[i] = (T1+T2-T3)/(1.0-rinf2);
      
    } else {

      // else m<0.01
      // Near or complete conservative scattering
      double amsig = att-sigb;
      double apsig = att+sigb;
	
      double rtp = (1.0-amsig*J4)/(1+amsig*J4);
      double rtm = (-1.0+apsig*J4)/(1+apsig*J4);
      rdd[i] = 5.0*(rtp+rtm);
      tdd[i] = 5.0*(rtp-rtm);
	
      double dns = ks*ks-m*m;
      double dno = ko*ko-m*m;
      double cks = (sb*(ks-att)-sf*sigb)/dns;
      double cko = (vb*(ko-att)-vf*sigb)/dno;
      double dks = (-sf*(ks+att)-sb*sigb)/dns;
      double dko = (-vf*(ko+att)-vb*sigb)/dno;
      double ho  = (sf*cko+sb*dko)/(ko+ks);
	
      rsd[i] = cks*(1.0-tss*tdd[i])-dks*rdd[i];
      rdo[i] = cko*(1.0-too*tdd[i])-dko*rdd[i];
      tsd[i] = dks*(tss-tdd[i])-cks*tss *rdd[i];
      tdo[i] = dko*(too -tdd[i])-cko*too*rdd[i];
	
      //  Multiple scattering contribution to
      // bidirectional canopy reflectance
      rsod[i] = ho*(1.0-tss*too)-cko*tsd[i]*too-dko*rsd[i];
    }
  
    //    Rcpp::Rcout << "value is " << std::endl << rsod << std::endl;

    
  }
  
  return Rcpp::List::create(rdd,rsd,rdo,rsod,tdd,tsd,tdo,too,tss,w);
  
} //  ReflTransSingleLayer


